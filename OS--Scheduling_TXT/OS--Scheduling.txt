## Scheduling

- Turnaround time v. Response Time

- Amortization: When there is a fixed cost of some operation, you can try and improve efficiency by reducing the number
					   of times that operation is performed.


STF (Shortest Job First)
- Only optimal assuming all jobs arrive at the same time. But this is not actually the case. A long-running job will be run first 
assuming it arrived before a short-running job. We are also assuming that we can know the runtime of the job in the first place


STCF (Shortest Time-to-Completion First)
- This scheduling method will “preempt” jobs to be resumed after running other jobs
- This is only optimal when considering turnaround time. Once the demand for interactivity is made, it is no longer
  enough...scheduling algorithms must consider response time.


RR (Round Robin)
- Only optimal if we consider response time, as each job is dragged on for much longer. RR is actually terrible for turnaround time.
- Jobs are executed cyclically during allocated time-slices (which are a multiple of the timer interupt period)

- In a vacuum, the shorter the timeslice the better the performance. There is overhead to switching active jobs, however; and as timelices get smaller
  and smaller, the context switches will become a bottleneck.
  
  
 I/O
 - I/O bound v. CPU-bound jobs 
 - A job will be blocked as it waits for I/O completion
 - Meaning that the OS can begin running another job while the I/O-blocked job isn't ready


Multi-Level Feedback Queue (MLFQ)
- As we said before, the OS cannot actually know how long a job will take to complete

- In an MLFQ, jobs will be placed into queues, and each queue will be assigned a priority level
- IF priority(QA) > priority(QB) QA runs
- IF priority(QA) == priority(QB) QA and QB run together in RR

- The MLFQ will automatically assume that a job will be short at first, but as the runtime increases, the jobs priority is reduced,
  so that known long-running jobs run after the what we assume are short-running jobs, thus emulating STCF without knowing runtime.

- After some time S, the scheduler should move jobs back up to the topmost queue.

- Acounting of CPU time should also be remembered. Once a process has reached its alloted duration, it would be moved down in priority.

- The scheduler does not necessarilly need to use a static table, though it can. The FreeBSD scheduler, for example, uses a formula to calculate priority.

- Some systems allow users to give “advidce” on how to set priorities.


